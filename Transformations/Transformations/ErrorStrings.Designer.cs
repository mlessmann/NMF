//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace NMF.Transformations {
    using System;
    using System.Reflection;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class ErrorStrings {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal ErrorStrings() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Transformations.ErrorStrings", typeof(ErrorStrings).GetTypeInfo().Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to There was no instantiating rule for an element of type {0}. Consider creating a transformation rule for this case and mark it instantiating for the {1}-rule.
        /// </summary>
        internal static string AbstractRuleCreateOutput {
            get {
                return ResourceManager.GetString("AbstractRuleCreateOutput", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to There was no instantiating rule for elements of type {0} and {1}. Consider creating a transformation rule for this case and mark it instantiating for the {2}-rule.
        /// </summary>
        internal static string AbstractRuleT2CreateOutput {
            get {
                return ResourceManager.GetString("AbstractRuleT2CreateOutput", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To call a transformation rule without specifying a selector, the input type TRequiredInput must be an assignable of TIn and the output type TRequiredOutput must be an assignable of TOut.
        /// </summary>
        internal static string Call1ArgNoSelectorMustInherit {
            get {
                return ResourceManager.GetString("Call1ArgNoSelectorMustInherit", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To call a transformation rule without specifying a selector, the input type TRequiredInput1 must be an assignable of TIn1, the input type TRequiredInput2 must be an assignable type of TIn2 and the output type TRequiredOutput must be an assignable of TOut.
        /// </summary>
        internal static string Call2ArgNoSelectorMustInherit {
            get {
                return ResourceManager.GetString("Call2ArgNoSelectorMustInherit", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To call a transformation rule without specifying a selector, the input type of the transformation must be an assignable of TIn and the output must be an assignable of TOut.
        /// </summary>
        internal static string CallTransNoSelectorMustInherit {
            get {
                return ResourceManager.GetString("CallTransNoSelectorMustInherit", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To call a transformation rule without specifying a selector, the input types of the transformation must be assignables of TIn1 and TIn2 and the output must be an assignable of TOut.
        /// </summary>
        internal static string CallTransT2NoSelectorMustInherit {
            get {
                return ResourceManager.GetString("CallTransT2NoSelectorMustInherit", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The output of this computation has been delayed. Please subscribe to the OutputInitialized event to get informed when the Output has been created. If you were using the trace functionality, consider using the Trace methods to get the computation objects and wait until the output has been created. Alternatively, change the structure of your transformation rules to ensure that this computation has been initialized when you are making your request..
        /// </summary>
        internal static string ComputationOutputDelayed {
            get {
                return ResourceManager.GetString("ComputationOutputDelayed", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To instantiate transformation rules, the input type TRequiredInput must be an assignable of TIn and the output type TRequiredOutput must be an assignable of TOut.
        /// </summary>
        internal static string MarkInstantiating1ArgMustInherit {
            get {
                return ResourceManager.GetString("MarkInstantiating1ArgMustInherit", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To instantiate transformation rules, the input type TRequiredInput1 must be an assignable of TIn1, the input type TRequiredInput2 must be an assignable of TIn2 and the output type TRequiredOutput must be an assignable of TOut.
        /// </summary>
        internal static string MarkInstantiating2ArgMustInherit {
            get {
                return ResourceManager.GetString("MarkInstantiating2ArgMustInherit", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To instantiate a transformation rule, the input type of the transformation must be an assignable of TIn and the output must be an assignable of TOut.
        /// </summary>
        internal static string MarkInstantiatingMustInherit {
            get {
                return ResourceManager.GetString("MarkInstantiatingMustInherit", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To instantiate a transformation rule, the input types of the transformation must be assignables of TIn1 and TIn2 and the output must be an assignable of TOut.
        /// </summary>
        internal static string MarkInstantiatingMustInheritT2 {
            get {
                return ResourceManager.GetString("MarkInstantiatingMustInheritT2", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This transformation already contains a rule of type {0}. Reflective transformation must not contain more than one rule per rule type..
        /// </summary>
        internal static string ReflectiveTransformationCustomRulesRuleTypeAlreadyInUse {
            get {
                return ResourceManager.GetString("ReflectiveTransformationCustomRulesRuleTypeAlreadyInUse", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The rule {0} cannot override the rule {1} because {0} does not inherit from {1}..
        /// </summary>
        internal static string ReflectiveTransformationOverrideNoInheritance {
            get {
                return ResourceManager.GetString("ReflectiveTransformationOverrideNoInheritance", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To require a transformation rule without specifying a selector, the input type TRequiredInput must be an assignable of TIn and the output type TRequiredOutput must be an assignable of TOut.
        /// </summary>
        internal static string Requires1ArgNoSelectorMustInherit {
            get {
                return ResourceManager.GetString("Requires1ArgNoSelectorMustInherit", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To require a transformation rule without specifying a selector, the input type TRequiredInput1 must be an assignable of TIn1, the input type TRequiredInput2 must be an assignable of TIn2 and the output type TRequiredOutput must be an assignable of TOut.
        /// </summary>
        internal static string Requires2ArgNoSelectorMustInherit {
            get {
                return ResourceManager.GetString("Requires2ArgNoSelectorMustInherit", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To require a transformation rule without specifying a selector, the input type of the transformation must be an assignable of TIn and the output must be an assignable of TOut.
        /// </summary>
        internal static string RequiresTransNoSelectorMustInherit {
            get {
                return ResourceManager.GetString("RequiresTransNoSelectorMustInherit", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To require a transformation rule without specifying a selector, the input types of the transformation must be assignables of TIn1 and TIn2 and the output must be an assignable of TOut.
        /// </summary>
        internal static string RequiresTransT2NoSelectorMustInherit {
            get {
                return ResourceManager.GetString("RequiresTransT2NoSelectorMustInherit", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The specified transformation rule to act as start rule is not a rule of the specified transformation!.
        /// </summary>
        internal static string TransformationEngineStartRuleNotRuleOfTransformation {
            get {
                return ResourceManager.GetString("TransformationEngineStartRuleNotRuleOfTransformation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The transformation rule {0} has been called with a wrong number of arguments..
        /// </summary>
        internal static string TransformationRuleWrongNumberOfArguments {
            get {
                return ResourceManager.GetString("TransformationRuleWrongNumberOfArguments", resourceCulture);
            }
        }
    }
}
